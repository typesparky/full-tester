#!/usr/bin/env python3
"""
TEST UNIFIED METHODOLOGY SIGNALS ON SP500

This script tests the unified methodology signals (politics, geopolitics, us_gdp)
generated by our 3-stage pipeline on SP500 percentage returns using different
strategy configurations.

We have 3 signals ready for testing:
- politics: 923 days (VALID for backtesting)
- geopolitics: 290 days (EMERGING)
- us_gdp: 72 days (EMERGING)
"""

import sys
import os
import pandas as pd
from pathlib import Path
from enum import Enum

# Add parent directory to path for imports
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from CORE.unified_analyzer import (
    SignalTesterAPI, AnalysisConfig,
    AssetType, SignalType, StrategyDirection, StrategyType
)
import logging

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)


class UnifiedSignalType(Enum):
    """Custom signal types for our unified methodology"""
    UNIFIED_POLITICS = "unified_politics"
    UNIFIED_GEOPOLITICS = "unified_geopolitics"
    UNIFIED_US_GDP = "unified_us_gdp"


def load_unified_signal(signal_type: UnifiedSignalType) -> pd.DataFrame:
    """Load a unified methodology signal"""
    signal_files = {
        UnifiedSignalType.UNIFIED_POLITICS: "test_signals/test_output_politics.csv",
        UnifiedSignalType.UNIFIED_GEOPOLITICS: "test_signals/test_output_geopolitics.csv",
        UnifiedSignalType.UNIFIED_US_GDP: "test_signals/test_output_us_gdp.csv"
    }

    filepath = Path(signal_files[signal_type])
    if not filepath.exists():
        raise FileNotFoundError(f"Signal file not found: {filepath}")

    df = pd.read_csv(filepath, parse_dates=['date'])
    df.set_index('date', inplace=True)

    # Use 'adjusted_signal' if available, otherwise 'signal'
    signal_col = 'adjusted_signal' if 'adjusted_signal' in df.columns else 'signal'
    df = df[[signal_col]].rename(columns={signal_col: 'signal'})

    logger.info(f"Loaded {signal_type.value}: {len(df)} days from {df.index.min()} to {df.index.max()}")
    return df


def create_custom_analyzer(signal_df: pd.DataFrame, config: AnalysisConfig) -> SignalTesterAPI:
    """Create a custom analyzer that uses our unified signal instead of the built-in ones"""

    class CustomSignalTester(SignalTesterAPI):
        def __init__(self, signal_data, config):
            self.signal_data_override = signal_data
            super().__init__(config)

        def _load_signal_data(self, signal_type):
            """Override to load our custom signal"""
            logger.info(f"Using custom unified signal data ({len(self.signal_data_override)} days)")
            return self.signal_data_override

    return CustomSignalTester(signal_df, config)


def run_unified_signal_test():
    """Run comprehensive testing of unified signals on SP500"""

    logger.info("=" * 80)
    logger.info("TESTING UNIFIED METHODOLOGY SIGNALS ON SP500")
    logger.info("=" * 80)

    # Define test configurations
    test_configs = [
        {
            'strategy': StrategyType.MOMENTUM,
            'direction': StrategyDirection.LONG_SHORT,
            'entry_percentile': 0.90,
            'description': "Momentum LongShort (90th percentile entry)"
        },
        {
            'strategy': StrategyType.MOMENTUM,
            'direction': StrategyDirection.LONG_ONLY,
            'entry_percentile': 0.95,
            'description': "Momentum LongOnly (95th percentile entry)"
        },
        {
            'strategy': StrategyType.MEAN_REVERSION,
            'direction': StrategyDirection.LONG_SHORT,
            'entry_percentile': 0.10,
            'description': "MeanRev LongShort (10th percentile entry)"
        }
    ]

    # Define which signals to test - start with just politics (VALID signal)
    signals_to_test = [
        UnifiedSignalType.UNIFIED_POLITICS,      # 923 days - VALID
    ]

    results = {}

    for signal_type in signals_to_test:
        logger.info(f"\nüß™ TESTING SIGNAL: {signal_type.value.upper()}")
        logger.info("=" * 60)

        try:
            # Load the signal
            signal_df = load_unified_signal(signal_type)
            signal_days = len(signal_df)
            signal_status = "VALID" if signal_days >= 500 else "EMERGING" if signal_days >= 50 else "INSUFFICIENT"

            logger.info(f"Signal quality: {signal_status} ({signal_days} days)")
            logger.info(f"Date range: {signal_df.index.min()} to {signal_df.index.max()}")
            logger.info(f"Signal range: {signal_df['signal'].min():.4f} to {signal_df['signal'].max():.4f}")

        except Exception as e:
            logger.error(f"Failed to load signal {signal_type.value}: {e}")
            continue

        signal_results = {}

        for config_spec in test_configs:
            logger.info(f"\n  üìà Strategy: {config_spec['description']}")

            try:
                # Create analysis config
                config = AnalysisConfig(
                    asset_type=AssetType.SP500,
                    signal_type=SignalType.POLYMARKET_VWP,  # Placeholder, we'll override
                    strategy_type=config_spec['strategy'],
                    strategy_direction=config_spec['direction'],
                    strategy_entry_percentile=config_spec['entry_percentile'],
                    initial_capital=10000.0,
                    min_signal_data_days=10,  # Override for short signals
                    output_dir="test_signals/sp500_results"
                )

                # Create custom tester with our signal
                tester = create_custom_analyzer(signal_df, config)

                # Run analysis
                tester.run()

                # Extract key results
                pnl = tester.pnl_results
                regression = tester.regression_results

                result_summary = {
                    'total_return': pnl.get('total_return', 0),
                    'annualized_return': pnl.get('annualized_return', 0),
                    'sharpe_ratio': pnl.get('sharpe_ratio', 0),
                    'max_drawdown': pnl.get('max_drawdown', 0),
                    'win_rate': pnl.get('win_rate', 0),
                    'num_trades': pnl.get('num_trades', 0),
                    'calmar_ratio': pnl.get('calmar_ratio', 0),
                    'regressions': regression
                }

                signal_results[str(config_spec['description'])] = result_summary

                # Print key metrics
                logger.info(f"    Total Return: {result_summary['total_return']:.1%}")
                logger.info(f"    Annualized Return: {result_summary['annualized_return']:.1%}")
                logger.info(f"    Sharpe Ratio: {result_summary['sharpe_ratio']:.2f}")
                logger.info(f"    Max Drawdown: {result_summary['max_drawdown']:.1%}")
                logger.info(f"    Win Rate: {result_summary['win_rate']:.1%}")
                logger.info(f"    Number of Trades: {result_summary['num_trades']:.0f}")

                # Check for significant regression results
                if '1m' in regression:
                    r2 = regression['1m'].get('r_squared', 0)
                    p_val = regression['1m'].get('p_value', 1)
                    logger.info(f"    1M Regression R¬≤: {r2:.3f}, p-value: {p_val:.3f}")

            except Exception as e:
                logger.error(f"    ‚ùå Analysis failed: {e}")
                signal_results[str(config_spec['description'])] = {'error': str(e)}

        results[signal_type.value] = signal_results

        # Quick summary of results for this signal
        logger.info(f"\nüìä SUMMARY for {signal_type.value}:")
        for strategy_name, result in signal_results.items():
            if 'error' not in result:
                total_ret = result['total_return']
                sharpe = result['sharpe_ratio']
                logger.info(f"  {strategy_name}: {total_ret:.1%} return, Sharpe {sharpe:.2f}")

    # Final summary
    logger.info(f"\n{'='*80}")
    logger.info("FINAL TEST SUMMARY")
    logger.info(f"{'='*80}")

    all_performances = []
    for signal_name, signal_results in results.items():
        for strategy_name, result in signal_results.items():
            if 'error' not in result:
                all_performances.append({
                    'signal': signal_name,
                    'strategy': strategy_name,
                    'total_return': result['total_return'],
                    'sharpe': result['sharpe_ratio']
                })

    if all_performances:
        # Sort by total return
        all_performances.sort(key=lambda x: x['total_return'], reverse=True)

        logger.info("üèÜ TOP PERFORMING STRATEGIES:")
        for i, perf in enumerate(all_performances[:5]):  # Top 5
            logger.info(f"{i+1}. {perf['signal']}: {perf['strategy']} - {perf['total_return']:.1%} (Sharpe: {perf['sharpe']:.2f})")
    else:
        logger.info("‚ùå No successful strategy tests")


def main():
    """Main test function"""
    logger.info("üöÄ Starting Unified Signals SP500 Testing")
    logger.info("Testing opportunity: Are our research-validated signals predictive of market returns?")

    run_unified_signal_test()

    logger.info("\n‚úÖ SP500 testing completed!")


if __name__ == "__main__":
    main()
